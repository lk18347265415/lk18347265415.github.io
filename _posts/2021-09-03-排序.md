---
layout: post
title:  "各种排序"
date:   2021-09-03 11:06:00 +0700
categories: [algorithm]
---

> 冒泡排序

```c
/*
 * 冒泡排序：将大数或小数往后移动，移到最后就形成了一个排好序的数组
 */
int a[6]={3,7,1,8,5,2};
int cur;
int i,j;
int length = sizeof(a)/sizeof(a[0]);
//递增排序
for(i = 0; i < length - 1; i++)//外层循环决定需要多少轮数的比较，i仅仅决定循环次数
{
	for (j = 0;j < leng - 1 -i;j++)//每次都取第一个数，一直对比到没有排序的位置为止
	{ 
        if(a[j] > a[j+1])//如果前一位比后一位大，交换两个值的位置
        {
            int tmp = a[j+1];
            a[j+1] = a[j];
            a[j] = tmp;
        }
    }       
}
//时间复杂度O(n^2)
```

> 插入排序

```c
/*
 * 插入排序：排好序的数放数组前面，新取得数要与已经排好序的数一起再次做一次排序得到排序好的整个数组
 */
int a[6]={3,7,1,8,5,2};
int cur;
int i,j;
int length = sizeof(a)/sizeof(a[0]);

for(i = 1; i < length; i++)//第一个数不需要排序，所以从第二个数开始排序，且i之前的数是为已经好序的数
{
	int cur = a[i];                          //记住a[i]的值，因为后面继续引用a[i]可能已经被别的值替换了(比较两个值的大小后要进行交换动作)
	for (j = i - 1;j >=0 && a[j] > cur;j--)//将a[i]和之前的数排序
	{ 
		a[j + 1] = a[j]; //前面的数比当前的数都要大，则将这些数整体向后移动。     
    }
    a[j + 1] = cur; //退出循环，表明a[j] <= cur（则j+1的位置为放置当前值的位置）或者j为-1了(-1表明当前值最小，需放在最前面)       
}
//时间复杂度O(n^2)
```

> 选择排序

```c
/*
 * 选择排序：从第一位开始，每次从剩下没排序的数组中找到最小的值放在排好序的数组后面
 */
int a[6]={3,7,1,8,5,2};
int cur;
int i,j;
int length = sizeof(a)/sizeof(a[0]);

for(i = 0; i < length - 1; i++)//最后一个数不需要排序，因为剩下的最后一个值肯定是最大的值
{
	for (j = i + 1;j < length;j++)//从i之后的数组中找到最小的数,然后将最小值放置在i位置
	{ 
		if(a[i] > a[j])//如果找到比a[i]还小的值，则将该值赋予给a[i],到最后保证a[i]为剩下数组中最小的值
        {
            int tmp = a[j];
            a[j] = a[i];
            a[i] = tmp;
        }
    }      
}
//时间复杂度O(n^2)
```

> 希尔排序

```c


```

> 堆排序（heapsort）

> ```c
> /*
>  * 堆是一个数组，它可以看成一个近似的完全二叉树，除了最底层外，该树是完全充满的。
>  * 给定一个节点的下标，我们很容易得到它的父节点、左孩子和右孩子.堆特征：父节点总是在其子节点的
>  * PARENT(i)
>  * 	  return i/2
>  * left(i)
>  *    return 2i
>  * right(i)
>  *    return 2i+1
>  */
> #define PARENT(i) i/2
> #define left(i) 2i
> #define right(i) 2i+1
> int a[10]={3,7,1,8,5,2,16,9,11,0};
> 
> //维护堆的性质
> void Max_heapify(int *a,int len,int i)
> {
>     int l,r,largest;
>     l = 2 * i;
>     r = 2 * i + 1;
>     printf("l = %d,r = %d\n",l,r);
>     if(l <= len&& a[l] > a[i])
>     {
>         largest = l;
>     }
>     else
>     {
>         largest = i;
>     }
>     if(r <= len && a[r] > a[largest])
>     {
>         largest = r;
>     }
>     if(largest != i)
>     {
>         int tmp = a[i];
>         a[i] = a[largest];
>         a[largest] = tmp;
>         Max_heapify(a,len,largest);
>     }	
> }
> void build_max_heap(int *a,int len)
> {
>     int i;
>     for(i = len/2;i > 0;i--)
>     {
>         Max_heapify(a,len,i);
>     }
> }
> void heap_sort(int *a,int len)
> {
>     int i;
>     build_max_heap(a,len);
>     for(i = len;i > 1;i--)
>     {
>         int tmp = a[1];
>         a[1] = a[i];
>         a[i] = tmp;
>         len = len - 1;
>         Max_heapify(a,len,1);//维护减去a[i]后的堆
>     }
> }
> ```

> 快速排序

```
```

> 归并排序

```c
```

