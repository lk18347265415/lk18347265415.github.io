---
layout: linux
title:  "硬中断原理及内核实现"
date:   2024-04-16 11:06:00 +0700
categories: [linux]
---

[TOC]

## 中断的概念

中断是一种改变程序正常执行流程的事件，可以由硬件设备甚至 CPU 本身生成。当中断发生时，当前的执行流程将暂停并运行中断处理程序。中断处理程序运行后，将恢复之前的执行流程。

## 中断分类

根据中断的来源，中断可以分为两类：

1. **同步(synchronous)**

   同步中断(通常称为异常)通过执行指令生成，处理器本身在执行指令过程中检测到的异常条件，比如除零和系统调用，错误指令等

   异常有两个来源：

   - ​	处理器检测到
     - 故障（faults）
     - 陷阱（traps）
     - 中止（aborts）

   - ​	程序（programmed）
     - int n（用指令的方式直接告诉CPU中断号，比如 INT 0x80）

2. **异步(asynchronous)**

   异步中断（通常称为中断）由外部事件生成，是由I/O设备生成的外部事件。例如，网卡生成中断来表示数据包已经到达，点击一下鼠标等。

根据推迟或暂时禁用中断的能力，它们还可以分为另外两类：

1. **可屏蔽的(maskable)**
   - 可以忽略的
   - 通过INT引脚发出信号

2. **不可屏蔽的(non-maskable)**
   - 不容忽略的
   - 通过NMI引脚发出信号

**不管是同步还是异步事件，都是让CPU收到一个中断号，同步事件的区别在于CPU自己执行指令时检测到的一些反常情况，然后自己给自己中断号即可，不需外界触发。而异步事件是借助可编程中断控制器硬件完成。**

## 可编程控制器

![PIC](D:\git资料\lk18347265415.github.io\_posts\pic\PIC.jpg)

支持中断的设备有一个输出引脚，用于发出中断请求信号。 IRQ 引脚连接到名为可编程中断控制器 (PIC) 的设备，该设备连接到 CPU 的 INTR 引脚。

PIC 通常具有一组用于与 CPU 交换信息的端口。当连接到 PIC IRQ 线之一的设备需要 CPU 关注时，会发生以下流程：

- 设备在相应的 IRQn 引脚上引发中断
- PIC将IRQ转换为向量号并将其写入端口以供CPU读取
- PIC 在 CPU INTR 引脚上引发中断
- PIC 在引发另一个中断之前等待 CPU 确认中断
- CPU确认中断然后开始处理中断

**注意**

>一旦 CPU 确认中断，中断控制器就可以请求另一个中断，无论 CPU 是否完成处理前一个中断。因此，根据操作系统控制 CPU 的方式，可能存在嵌套中断



## 中断描述符

当CPU收到中断号后，会去中断描述符表(IDT)中查找对应向量的中断描述符，并从中断描述符中找到中断处理程序的地址，然后跳转过去执行。

### 中断描述表结构

中断描述表就是在内存中的一个数组而已，每条数据占用8字节，以 linux-2.6.0 源码为例：

```c
struct desc_struct idt_table[256] = { {0, 0}, };

//desc_struct结构
struct desc_struct {
    unsigned long a,b;
};
```

让我们看一下 IDT 条目的几个字段：

- 段选择器，索引 GDT/LDT 以查找中断处理程序所在代码段的开头
- offset，代码段内的偏移量
- T，代表闸门类型
- DPL，使用段内容所需的最低权限

![IDT](D:\git资料\lk18347265415.github.io\_posts\pic\IDT.jpg)

### 中断描述符初始化

操作系统初始化时，会把各中断描述符填充到中断描述符中，一下是在 Linux-2.6.0 内核源码的 traps.c 文件初始化文件描述符的片段：

```
void __init trap_init(void) {
    set_trap_gate(0, &divide_error);
    ...
    set_trap_gate(6, &invalid_op);
    ...
    set_intr_gate(14, &page_fault);
    ...
    set_system_gate(0x80, &system_call);
}
```

