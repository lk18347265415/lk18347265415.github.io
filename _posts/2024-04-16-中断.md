---
layout: linux
title:  "硬中断原理及内核实现"
date:   2024-04-16 11:06:00 +0700
categories: [linux]
---

[TOC]

## 中断的概念

中断是一种改变程序正常执行流程的事件，可以由硬件设备甚至 CPU 本身生成。当中断发生时，当前的执行流程将暂停并运行中断处理程序。中断处理程序运行后，将恢复之前的执行流程。其实，操作系统就是一个中断驱动的死循环，其他所有事情都是由操作系统提前注册的中断机制和其对中断处理函数完成。

## 中断分类

根据中断的来源，中断可以分为两类：

1. **同步(synchronous)**

   同步中断(通常称为异常)通过执行指令生成，处理器本身在执行指令过程中检测到的异常条件，比如除零和系统调用，错误指令等

   异常有两个来源：

   - ​	处理器检测到
     - 故障（faults）
     - 陷阱（traps）
     - 中止（aborts）

   - ​	程序（programmed）
     - int n（用指令的方式直接告诉CPU中断号，比如 INT 0x80系统调用）

2. **异步(asynchronous)**

   异步中断（通常称为中断）由外部事件生成，是由I/O设备生成的外部事件。例如，网卡生成中断来表示数据包已经到达，点击一下鼠标等。

根据推迟或暂时禁用中断的能力，它们还可以分为另外两类：

1. **可屏蔽的(maskable)**
   - 可以忽略的
   - 通过INT引脚发出信号

2. **不可屏蔽的(non-maskable)**
   - 不容忽略的
   - 通过NMI引脚发出信号

**不管是同步还是异步事件，都是让CPU收到一个中断号，同步事件的区别在于CPU自己执行指令时检测到的一些反常情况，然后自己给自己中断号即可，不需外界触发。而异步事件是借助可编程中断控制器硬件完成。**

## 可编程控制器

![PIC](D:\git资料\lk18347265415.github.io\_posts\pic\PIC.jpg)

支持中断的设备有一个输出引脚，用于发出中断请求信号。 IRQ 引脚连接到名为可编程中断控制器 (PIC) 的设备，该设备连接到 CPU 的 INTR 引脚。

PIC 通常具有一组用于与 CPU 交换信息的端口。当连接到 PIC IRQ 线之一的设备需要 CPU 关注时，会发生以下流程：

- 设备在相应的 IRQn 引脚上引发中断
- PIC将IRQ转换为向量号并将其写入端口以供CPU读取
- PIC 在 CPU INTR 引脚上引发中断
- PIC 在引发另一个中断之前等待 CPU 确认中断
- CPU确认中断然后开始处理中断

**注意**

>一旦 CPU 确认中断，中断控制器就可以请求另一个中断，无论 CPU 是否完成处理前一个中断。因此，根据操作系统控制 CPU 的方式，可能存在嵌套中断



## 中断描述符

当CPU收到中断号后，会去中断描述符表(IDT)中查找对应向量的中断描述符，并从中断描述符中找到中断处理程序的地址，然后跳转过去执行。

### 中断描述表结构

中断描述表就是在内存中的一个数组而已，每条数据占用8字节，以 linux-2.6.0 源码为例：

```c
struct desc_struct idt_table[256] = { {0, 0}, };

//desc_struct结构
struct desc_struct {
    unsigned long a,b;
};
```

让我们看一下 IDT 条目的几个字段：

- 段选择器，索引 GDT/LDT 以查找中断处理程序所在代码段的开头
- offset，代码段内的偏移量
- T，代表闸门类型
- DPL，使用段内容所需的最低权限

![IDT](D:\git资料\lk18347265415.github.io\_posts\pic\IDT.jpg)

### 中断描述符初始化

操作系统初始化时，会把各中断描述符填充到中断描述符中，一下是在 Linux-2.6.0 内核源码的 traps.c 文件初始化文件描述符的片段：

```
void __init trap_init(void) {
    set_trap_gate(0, &divide_error);
    ...
    set_trap_gate(6, &invalid_op);
    ...
    set_intr_gate(14, &page_fault);
    ...
    set_system_gate(0x80, &system_call);
}
```

刚刚提到的**除法异常、非法指令异常、缺页异常**等，以及之后可能通过 INT 0x80 触发**系统调用**的中断处理函数 system_call，通过这个函被写到了中断描述符表里。

### CPU怎么定位到中断描述表

怎么定位中断描述表，各个操作系统方法不一致，想放在哪里就放在哪里，单需要通过某种方式告诉CPU。CPU的IDTR寄存器存放中断描述符表的起始地址以及大小，即操作体统用LIDT指令将idt_table数组地址放在IDTR寄存器中。Linux-2.6.0源码中是这样构造这个结构的：

```c
idt_descr:
    .word 256 * 8 - 1
    .long idt_table

lidt idt_descr
```

这样，CPU 收到一个中断号后，**中断描述符表的起始位置从 IDTR 寄存器中可以知道，而且里面的每个中断描述符都是 64 位大小，也就是 8 个字节，那很简单就能查询到这个中断号对应的中断描述符**。

## 注册中断处理程序

​	中断处理程序是管理硬件的驱动程序的组成部分。每一个设备都有相关的驱动程序，如果设备使用中断（大部分设备如此），那么相应的驱动程序就注册一个中断处理程序。

​	驱动程序可以通过request_irq()函数注册一个中断处理程序，它被声明在<linux/interrupt.h>中，该函数激活给定的中断线，以处理中断，通过free_irq可以卸载已经安装的中断。

```reStructuredText
int request_irq(unsigned int irq,
				irq_handler_t handler,
				unsigned long flags,
				const char *name,
				void *dev)
参数：
irq:中断号
handler：中断处理函数
flags：中断标志位掩码
	● IRQ_DISABLED:该标志被设置,内核处理中断程序期间,要禁止所有的其它中断
	● IRQF_SHARED：表示共享中断。当多个设备共享同一个中断线时，可以设置此标志。共享中断时，中断处理程序必须能够区分是哪个设备引起的中断。
	...
name: 与中断相关的设备的ASCII文本表示，如键盘中断对应的"keyboard"
dev: 用于共享中断线，无需共享中断线时，该参数可以为空

//释放中断线
free_irq(unsigned int irq, void *dev);
```

## 中断控制

​	Linux内核提供了一组接口用于操作机器上的中断状态。这些接口为我们提供了能够禁止当前处理器的中断系统，或屏蔽整个机器的一条中断线的能力，这些都与体系结构相关。

​	控制中断系统的原因归根结底是要提供同步。通过禁止中断，可以确保某个中断处理程序不会抢占当前的代码。此外，禁止中断还可以禁止内核抢占。然而，在多处理器上，没有任何机制来防止来自其它处理器的并发访问，因此，内核代码都需要获取锁，防止来自其它处理器对共享数据的并发访问。获取这些锁的同时也伴随着禁止本地中断。

### 禁止和激活中断

​	用于禁止当前处理器（仅仅是当前处理器）上的本地中断，随后又激活他们的语句为：

```c
local_irq_disable();
/* 禁止中断 */
local_irq_enable();
```

这两个函数通产以单个汇编指令来实现（依赖于具体体系结构）。实际上x86中local_irq_disable仅仅是cli指令，而local_irq_enable只不过是sti指令。cli和sti分别是clear和set允许中断贬值的汇编调用。因为这两个函数的粒度太大，总是关闭或打开所有中断，而我们想要的是恢复之前状态的中断。因此在中断之前保存中断系统的状态会更加安全一些。在准备激活中断时，只需要吧中断恢复到他们原来的状态即可：

```
unsigned long flags;
local_irq_save(flags); /* 禁止中断 */
/* ... */
local_irq_restore(flags) /* 中断被恢复到他们原来的状态 */
```

### 禁止指定中断线

在某些情况下我们不需要禁止处理器上所有中断，而只禁止整个系统中的一条特定的中断线就够了。这就是所谓的屏蔽掉(masking out)一条中断线。作为例子。你可能想在对中断的状态操作之前禁止设备中断的传递。为此，Linux提供了四个接口：

```
void disable_irq(unsigned int irq);
void disable_irq_nosync(unsigned int irq);/* 不会等待当前中断处理程序执行完毕 */
void enable_irq(unsigned int irq);
void synchronize_irq(unsigned int irq);/* 等待一个特定的中断处理程序的退出 */
```

## 总结

本章所讲解的中断都为硬中断，因为这些都是依赖CPU这个硬件实现的中断机制。因为中断打断了其它代码的执行，所以他们必须快速的执行完，特别是在中断处理程序中禁止所有中断会影响整个CPU的性能。所以每个硬中断最好处理简单的程序就完成。如果碰到需要处理大量数据的中断，为了在大量工作与必须快速执行完成之间求得一种平衡，内核把处理中断的工作氛围两半部分。本章讲解的就是上半部分。而中断的下半部分一般用户处理中断的耗时任务。总之，中断是操作系统一个特别重要的功能，大多数现代硬件都是通过中断与操作系统通信。像linux整个系统都是处于while(1)大循环中，随时等待中断信号的来临。