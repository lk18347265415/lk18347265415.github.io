# PG18新特性：虚拟列

## 概述

​	自PG12发布存储列功能以来，社区一直在推动虚拟列的工作，这次PG18带来了虚拟列功能。虚拟列是一种不存储数据的表列，其值在查询时通过动态计算得出。与存储列相比，虚拟列节省了列存储空间，查询虚拟列值时通过计算虚拟列表达式的值作为该列的值。

## 虚拟列的使用

### 基本语法	

PG18中虚拟列的语法和存储列的语法相似，新增加关键字**VIRTUAL**，当省略STORED 和VIRTUAL 关键字时默认为虚拟列。其语法如下所示：

> **GENERATED ALWAYS AS ( generation_expr ) [ STORED | VIRTUAL ]**

瀚高数据库管理系统V9中也同样支持了虚拟列的功能，其中瀚高数据库管理系统V9中虚拟列的语法完全更加丰富，虚拟列的语法完全兼容了Oracle。瀚高数据库管理系统V9中虚拟列的语法如下所示：

>**column [datatype] [GENERATED ALWAYS] AS (column_expression)[VIRTUAL]**

### 虚拟列用例

虚拟列的标识是在列的限制条件中表示的，通过虚拟列的限制语法标识列为虚拟列，以下为虚拟列表的创建、查询和新增虚拟列：

```sql
-- 创建包含虚拟列的表，其中price_with_tax为虚拟列
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    price NUMERIC(10,2) NOT NULL,
    tax_rate NUMERIC(5,2) DEFAULT 0.20,
    price_with_tax NUMERIC(10,2) GENERATED ALWAYS AS (price * (1 + tax_rate)) VIRTUAL
);

-- 插入数据
INSERT INTO products (name, price, tax_rate) 
VALUES ('Laptop', 1000.00, 0.20);

-- 查询数据（虚拟列自动计算）
SELECT name, price, tax_rate, price_with_tax FROM products;
  name  |  price  | tax_rate | price_with_tax 
--------+---------+----------+----------------
 Laptop | 1000.00 |     0.20 |        1200.00
(1 row)

--为表添加虚拟列
ALTER TABLE products ADD COLUMN selling_price NUMERIC(10,2)
GENERATED ALWAYS AS (
    price * (1 - 0.2) * (1 + tax_rate)
) virtual;
```

## 实现原理

### 虚拟列的创建

创建的表中虚拟列的存储方式和普通列的存储方式类似，其列信息都存储在pg_attribute系统表中，其中attgenerated列存储生成列信息，如果该列的值为's',表示该列为存储列。PG18新增的虚拟列在该字段中的标识符为'v'，并且将虚拟列的表达式存储于pg_attrdef系统表中。

```sql
--查看虚拟列信息，其attgenerated为v表示该列为虚拟列
postgres=# select * from pg_attribute where attname='price_with_tax';
-[ RECORD 1 ]--+---------------
attrelid       | 16388
attname        | price_with_tax
atttypid       | 1700
attlen         | -1
attnum         | 5
atttypmod      | 655366
attndims       | 0
attbyval       | f
attalign       | i
attstorage     | m
attcompression | 
attnotnull     | f
atthasdef      | t
atthasmissing  | f
attidentity    | 
attgenerated   | v
attisdropped   | f
attislocal     | t
attinhcount    | 0
attcollation   | 0
attstattarget  | 
attacl         | 
attoptions     | 
attfdwoptions  | 
attmissingval  |

--查看虚拟列表达式存储，可以看到以下表达式为虚拟列表达式
postgres=# select pg_get_expr(adbin, adrelid) from pg_attrdef where adnum = 5;
             pg_get_expr             
-------------------------------------
 (price * ((1)::numeric + tax_rate))
(1 row)
```

### 虚拟列的插入或更新

由于虚拟列的数据不占据存储空间，所以任何指定更新或插入虚拟列的操作都将被限制。

```sql
--指定插入虚拟列
INSERT INTO products (name, price, tax_rate, price_with_tax) VALUES ('Laptop', 1000.00, 0.20, 1);
ERROR:  cannot insert a non-DEFAULT value into column "price_with_tax"
DETAIL:  Column "price_with_tax" is a generated column.

--指定更新虚拟列
update products set price_with_tax = 1 where name = 'Laptop';
ERROR:  column "price_with_tax" can only be updated to DEFAULT
DETAIL:  Column "price_with_tax" is a generated column.
```

### 虚拟列的查询

PG18中查询虚拟列的实现是在生成执行计划阶段完成。在逻辑重写优化阶段，判断查询的范围表中是否包含虚拟列，如果包含虚拟列，则将该虚拟列的表达式从pg_attrdef中获取出来并替换原虚拟列名。这样，查询虚拟列的值就相当于计算其表达式的值，即select price_with_tax相当于select (price * ('1'::numeric + tax_rate)) as price_with_tax。可以看到以下虚拟列被替换成了其表达式：

```sql
postgres=# explain verbose SELECT name, price, tax_rate, price_with_tax 
FROM products;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Seq Scan on public.products  (cost=0.00..23.12 rows=750 width=76)
   Output: name, price, tax_rate, (price * ('1'::numeric + tax_rate))
(2 rows)
```

## 适用场景

- 当考虑存储空间时，可以使用虚拟列，因为虚拟列不占用磁盘空间
- 当列的值需要根据依赖的列变化而变化时，需要使用虚拟列。因为虚拟列的值是动态获取的
- 当虚拟列表达式简单时，可以使用虚拟列。因为查询虚拟列需消耗CPU资源，表达式复杂会消耗太多CPU资源
- 因为oracle中有虚拟列功能，更加方便oracle的虚拟列迁移至PostgreSQL中

## 待完善部分

一些功能目前尚不支持，但可能会作为增量功能在后续的版本中添加：

- 在虚拟列上创建索引或使用虚拟列
- 因此虚拟列上也没有唯一约束
- 虚拟列上的扩展统计信息
- 虚拟列上的外键约束
- 虚拟列上的非空约束（支持检查约束）
- ALTER TABLE / DROP EXPRESSION
- 虚拟列不能具有域类型
- 逻辑复制不支持虚拟列

## 总结

虚拟列与普通列和存储列有着本质的不同，因为虚拟列的值不占磁盘空间，其获取值的方式也与普通列和存储列不同，普通列或存储列需要从磁盘获取数据，而虚拟列是通过动态计算获取虚拟列的值。