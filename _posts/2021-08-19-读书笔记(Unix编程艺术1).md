---
layout:	post
title:	"读书笔记(Unix编程艺术1)"
date:	2021-08-19 15:58:00 +0800
categories:	[reading_note]
---

> 软件透明性

Unix传统非常重视一些设计品质，但很少明确谈论过，那就是：**透明性**和**可显性**。如果没有阴暗的角落和隐藏的深度，软件系统就是透明的。透明性是一种被动品质。如果能预测到程序行为的全部和大部分情况，并能建立简单的心里模型，这个程序就是透明的，因为可以看透机器究竟在干什么。

> 透明性实例

<table border='1'>
    <tr>
        <td>用例</td>
        <td>描述</td>
    </tr>
    <tr>
        <td>audacity</td>
        <td>audacity是一个开源的声音文件编辑器，这个程序支持对音频采样的剪切、粘贴和编辑操作，支持多声道编辑和混音。audacity窗口显示声音波行图，可以剪切和粘贴波形图。</td>
    </tr>
    <tr>
        <td>fetchmail</td>
        <td>fetchmail主要是在POP3或IMAP的远程邮件协议和互联网自带的SMTP协议之间进行转换，从而进行电子邮件交换。它的命令选项不少于60个，-v选项可以查看详细信息，即fetchmail将发生的每一单POP、IMAP和SMTP处理都转储到标准输出设备中。开发者真正能够实时看到远程邮件服务及邮件传输程序的协议处理代码</td>
    </tr>
    <tr>
        <td>GCC</td>
        <td>GCC由一系列处理阶段组成，并由一个驱动程序将其紧密结合在一起。它们是：预处理器、解析器、代码生成器、汇编器和链接器。前三个阶段都接受可读文本格式的输入，然后输出可读的文本格式（汇编器必须输出而连接器必须输入二进制格式）。因为各个中间格式的大部分都是文本格式，中间结果可以使用diff对比结果是否偏离预期结果，而没必要使用专门的转储-分析工具</td>
    </tr>
    <tr>
        <td>SNG（Scriptable Network Graphics,可脚本化网络图形）</td>
        <td>sng程序在PNG图形格式及其纯文本形式之间进行转换，这个文本表达可用普通的文本编辑器检查和修改。用户只需要将图像转换成纯文件表达式，对之进行编辑，最后再转换回图像。sng程序的代码本身并不特别透明，但是通过让PNG的全部内容可显，提高了程序中较大系统的透明性</td>
    </tr>
    <tr>
        <td>Terminfo数据库</td>
        <td>Terminfo主要是视频显示终端的描述符集，每一条记录描述了在终端屏幕上执行的不同操作的转义序列，例如插入或删除行、删除光标位置到行尾或屏幕端的全部内容、开始或结束反向、下划线和闪烁等屏幕高亮显示。Terminfo数据库主要由curses库使用。这些构成了“roguelike”式接口风格的基础，也构成了mutt、lynx和slrn等广泛使用程序的基础。terminfo本身使用文件系统作为简单的层级数据库。这种偷懒相当具有建设性，符合经济性原则和透明性原则。</td>
    </tr>
</table>

> 透明性之禅

要追求代码的透明，最有效的方法很简单，就是不要在具体操作的代码上叠放太多的抽象层。建议对引起设计问题的特殊、意外的情况进行抽象、简化和概括，并尽量从中分离出来。

​	禅的一个主要教导是，通常我们都投过源于欲望的偏见和城建的迷雾来观看世界。要开悟，我们必须遵循禅的教导，不仅要“去欲望，少依恋”，还要“如实见”——不要让偏见和城建蒙住了眼。

> 为透明性和可显性而编码

透明性和可显性同模块性一样，主要是设计的特性而不是代码的特性。仅仅做对一些底层风格的要素，如清晰 统一的代码缩进，或具有良好的变量命名约定，是不够的。这些特性更多与代码中不易硬性规定的特性有关。一下这些问题需要好好思考：

- 程序调用层次中最大的静态深度是多少？也就是说不考虑递归，为了简历心里模型来理解代码的操作，人们将要调用多少层？提示：如果大于4，就要当心
- 代码是否具有强大、明显的不变性质？不变性质帮助人们推演代码和发现有问题的情况
- 每个API中的各个函数调用是否正交？或者是否存在太多的特性标志（magic flags）和模式位，使得一个调用要完成多个任务？完全避免模式标志会导致混乱的API，里面包括太多几乎一模一样的函数，但是频繁使用模式标志更容易产生错误（很多易忘并且易混的模式标记）。
- 是否存在一些顺手可用的关键数据结构或全局唯一的记录器（scoreboard），捕捉了系统的高层级状态？这个状态是否容易被形象化和检验，还是分布在数目众多的各个全局变量或对象中，而难以找到？
- 程序的数据结构或分类和它们所代表的外部实体之间，是否存在清晰的一对一映射？
- 是否容易找到给定函数的代码部分？不仅单个函数、模块，还有整个代码，需要花多少经理才能读懂？
- 代码增加了特殊情况还是 避免了特殊情况？每个特殊情况可能对任何其它特殊情况产生影响；所有隐含的冲突都是bug滋生的温床。然而更重要的是，特殊情况使得代码更难理解。
- 代码中有多少个magic number（含义含糊的常量）？通过审查是否很容易查出实现代码中的限制（比如关键缓冲区的大小）？

> 为可维护性而设计

如果作者以外的其他人能够顺利地理解和修改软件，则这个软件就是可维护的。可维护性不仅要求代码能够运行；还要求代码能够遵循清晰原则，并且和人以及计算机沟通。

一个非常重要的时间就是用用清晰原则：选择简单的算法，引用ken Thompson的话：“拿不准，用穷举”。Tompson完全明白复杂算法的代价——不仅在于开始实现时容易出bug，而且更在于维护这要完全理解这些算法更困难。

另一个重要的时间时要包含开发者手册（hacker‘s guide）。在发布源码的同时包含知道文档，简略地描述代码的关键数据结构和算法，这种做法永远得到高度的认可。实际上，跟编写最终用户文档相比，Unix程序员常常更善于编写开发者手册。

开源社区已经抓住并且细述了这个习惯，除了能给未来的维护者提出建议之外，开源项目的开发者指南也是为了便于临时贡献者增加功能和修改bug而设计的。